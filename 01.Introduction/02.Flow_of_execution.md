



# C++ File Extenstion


 A file extension is the suffix at the end of a filename, usually after a dot (`.`), that indicates the file type and tells the operating system which program can open it.

* **Format** : `filename.extension`
* Example: `hello.cpp`, `report.pdf`, `image.jpg`

 we use both `.cpp` and `.cc` are valid C++ source file extensions.

The difference is mostly **convention and platform preference** â€” `.cpp` is more common on Windows and in Microsoft ecosystems,

 while `.cc` is widely used on Unix/Linux systems. Functionally, compilers treat them the same





# Flow of Execution

![1763896032837](image/02.Flow_of_execution/1763896032837.png)

## Example

```cpp
// Prog1.cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, Yaswanth!" << endl;
    return 0;
}

```



In terminal we can simply  run these  commands to run program

g++ prog1.cpp -o prog1

./prog1



### ðŸ”¹1. **Source Code File**

Human-readable C++ program written in `.cpp` file **(e.g., `prog1.cpp`).**

* **Role** : Contains your logic, functions, and instructions.
* Analogy: Your blueprint for a machine.

### ðŸ”¹ 2. **C++ Preprocessor**

**The preprocessor handles directives like `#include`, `#define`, and removes comments.**

* **Output** : A temporary expanded source file (often seen with `gcc -E prog1.cpp`).
* **Visibility** : You can dump this expanded file to stdout to see all included headers expanded.
* Handles `#include <iostream>` â†’ pulls in the actual code from the iostream header.
* Removes comments.
* Expands macros (`#define`, etc.).

  **Result** : A big temporary file with all headers and macros expanded.

  **Analogy** : Like unpacking all tools and instructions before building â€” you now have the full blueprint.

For Preprocessing run the

```cpp
g++ -E prog1.cpp -o prog1.i
```

Now we will get output as  prog1.i

### ðŸ”¹ 3. **Compiler**

**Compiler translates preprocessed C++ code into assembly language instructions.**

* **Output** : `.s` file (assembly code).
* **Visibility** :Run `g++ -S prog1.cpp` â†’ generates `prog1.s` (you can open it in a text editor to see assembly instructions like `mov`, `call`).
* **Output** : `Prog1.s` (Assembly code)
* **What it does** :

  * Converts C++ code into  **assembly language** .
  * Assembly is low-level, human-readable instructions for the CPU.

    **Result** : `Prog1.s` â€” a file with instructions like `mov`, `call`, `jmp`.

  **Analogy** : Translating your blueprint into step-by-step build instructions.

  Run below  Compilation to assembly

  ```
  g++ -S prog1.cpp -o prog1.s
  ```

now we get prog1.s file

### ðŸ”¹ 4. **Assembler**

**Assembler converts assembly (`.s`) into machine code (binary instructions).**

* **Output** : `.o` file (object code).
* **Visibility** : Run `g++ -c prog1.cpp` â†’ generates `prog1.o`.
  This is binary, not human-readable, but you can inspect with tools like `objdump`.
* **What it does** :

  * Converts assembly into **machine code** (binary).
  * This is what the CPU actually understands.

    **Result** : `Prog1.o` â€” compiled machine code, but not yet runnable.

    **Analogy** : Building individual robot parts from instructions.

### ðŸ”¹ 5. **Linker**

**Linker combines your object file (`.o`) with required libraries (like `libstdc++` for `iostream`).**

* **Output** : Executable file (`a.out` by default, or `prog1` if specified).
* **Visibility** : Run `g++ prog1.o -o prog1` â†’ produces executable.
* **What it does** :

  * Combines your object code with external libraries.
  * Resolves function calls like `cout`.

  **Result** : `Prog1` â€” a complete, runnable program.

 **Analogy** : Assembling all parts into a working robot and plugging it into power.

Assembly to object code

```cpp
g++ -c prog1.cpp -o prog1.o
```

 we will get output as  prog1.o

<pre><div># Linking to executable</div></pre>

```cpp
g++ prog1.o -o prog1
```

## 6. Final Step: Execution

**The operating system loads the executable into memory and starts execution at the `main()` function.**

* **Output** : Program runs and produces runtime output (e.g., prints to console).
* **Visibility** : Run `./prog1` â†’ see program output.

Now when you run `./Prog1` or `Prog1.exe`, the  **runtime flow begins** :

```
Output:
Hello, Yaswanth!
```

Execution starts at `main()`, runs line by line, and ends at `return 0;`.

# Preprocessing only

g++ -E prog1.cpp -o prog1.i

# Compilation to assembly

g++ -S prog1.cpp -o prog1.s

# Assembly to object code

g++ -c prog1.cpp -o prog1.o

# Linking to executable

g++ prog1.o -o prog1

# Execution

./prog1

* `.i` â†’ Preprocessed source (expanded headers/macros).
* `.s` â†’ Assembly code (human-readable low-level instructions).
* `.o` â†’ Object code (binary machine instructions).
* Executable â†’ Final runnable program.

you **can see each step** by using compiler flags (`-E`, `-S`, `-c`) before linking.
